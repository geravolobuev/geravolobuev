I"7\<h2 id="многопоточность-в-ios">Многопоточность в iOS</h2>

<p>Курс неплохой. Обзорный. Хотя, в организационном плане, уступает курсам, например, Яндекса. Спикер уставшим голосом рассказывает тему, часто как будто «с бумажки». Тесты и вопросы попадаются с ошибками, не очень понятными формулировками. По окончанию курса выдается сертификат.</p>

<p>Небольшой конспект по лекциям.</p>

<h3 id="multithreading">Multithreading</h3>

<p>Главным потоком называется поток, в котором стартует наше приложение. Все взаимодействие с интерфейсом (UI) происходит в нем.</p>

<p>Основным примитивом многопоточность является поток (thread)</p>

<p>Thread класс - objC обертка над unix потоками для удобного создания потоков.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nv">nsthread</span> <span class="o">=</span> <span class="kt">Thread</span><span class="p">(</span><span class="nv">block</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Test 2"</span><span class="p">)</span>
<span class="p">})</span>
<span class="n">nsthread</span><span class="o">.</span><span class="nf">start</span><span class="p">()</span></code></pre></figure>

<p>Quality of Service - позволяет задавать приоритет задачам. 
Существует четыре типа QoS:<br />
<strong>userInteractive</strong> - используется для задач взаимодействия с пользователем на главном потоке. Анимации, обновление интерфейса.<br />
<strong>userInitiated</strong> - используется для задач, которые требуют немедленного результата, и которые влияют на действия пользователя. Сохранение документа, клик пользователя.<br />
<strong>unility</strong> - используется для задач, которые не требуют немедленных результатов. Загрузка данных.<br />
<strong>background</strong> - используется для задач, невинных пользователю. Синхронизация, бекап. <br />
Также есть тип default. Если уровень на выставлен, по умолчанию ставиться default.</p>

<p>Для создания пишут:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">thread</span><span class="o">.</span><span class="n">qualityOfService</span> <span class="o">=</span> <span class="o">.</span><span class="n">userInitiated</span></code></pre></figure>

<p>Более высокий приоритет означает лишь то, что потоку будет чаще даваться возможность выполняться, но это не значит, что ему будет предоставлена возможность выполниться первым</p>

<p>__
Синхронизация - позволяет обеспечит доступ, одного или нескольких потоков к одному ресурсу. Для этого есть два примитива - mutex и semaphore. 
Первый позволяет обращаться к ресурсу только одному потоку, семафор позволяет обращаться н-ому количеству потоков.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">lock</span> <span class="o">=</span> <span class="kt">NSLock</span><span class="p">()</span>
<span class="kd">func</span> <span class="nf">test</span><span class="p">(</span><span class="kt">I</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">lock</span><span class="o">.</span><span class="nf">lock</span><span class="p">()</span> <span class="c1">// захват ресурса </span>
	<span class="c1">// do somth</span>
	<span class="n">lock</span><span class="o">.</span><span class="nf">unlock</span><span class="p">()</span> <span class="c1">// освобождение ресурса</span>
<span class="p">}</span></code></pre></figure>

<p>Под захватом ресурса подразумевается, что как только поток обратиться к ресурсу, никакой другой поток не сможет взаимодействовать с ресурсом и будет ожидать момента, когда первый освободит ресурс.</p>

<p>Рекурсивный mutex - позволяет потоку множество раз захватывать один и тот же ресурс:</p>

<p>let lock = NSRecursiveLock()
func test1() {
	lock.lock()
	test2()
	lock.unlock()
}
func test2() {
	lock.lock()
	// do somth
	lock.unlock()
}</p>

<p>__
Задача закрытая condition не начнет выполнятся пока не получит сигнал (signal) из другого потока:</p>

<p>private let condition = NSCondition()
private var check: Bool = false</p>

<p>func test1() {
    condition.lock()
    while(!check) {
        condition.wait()
        }
    print(“test”)
    condition.unlock()
}
func test2() {
    condition.lock()
    check = true
    condition.unlock()
}
let thread1 = Thread {
    test1()
}
thread1.start()
let thread2 = Thread {
    test2()
}
thread2.start()</p>

<p>__
Context switch - происходит при переключении между потоками. Это довольно «дорогостоящая» операция системы. Для мьютексов есть очередность выполнение. В случае с unfair lock предпочтение будет отдаваться тому потоку, который обращается к ресурсу чаще.</p>

<p>private var lock = os_unfair_lock_s()
func test(i: Int) {
   os_unfair_lock_lock(&amp;lock)
   sleep(1)
   print(i)
   os_unfair_lock_unlock(&amp;lock)
}</p>

<p>__
Типичные проблемы при работе с потоками:
Deadlock - Состояние, при котором каждый участник (поток) ждет когда другой участник «отпустит» lock.  Т.е. потоки пытаются обратиться к уже захваченным ресурсам, в следствии чего программа зависает.
LiveLock - Тоже, что и deadlock, только состояние процессов задействованных в действиях постоянно меняются, но прогресса в выполнении работы не происходит. Оба потока выполняет бесполезную работу.
Priority Inversion - Низкоприоритетный поток захватывает ресурс, остальные потоки ждут.</p>

<p>Библиотека Grand Central Dispatch</p>

<p>Основной примитив GCD - очередь (Queue). Есть два типа:</p>
<ol>
  <li>Serial - выполняет задачи последовательно.</li>
  <li>Concurrent - позволяет выполнять задачи одновременно.</li>
</ol>

<p>let serialQueue = DispatchQueue(label: «serialTest»)
let concurrentQueue = DispatchQueue(label: «concurrentTest», attributes: .concurrent)</p>

<p>Также можно получить очередь из пула очередей. Для этого нужно обратиться к global:
let globalQueue = DispatchQueue.global()
Все глобальные очереди - concurrent. Кроме очереди main:
let mainQueue = DispatchQueue.main
Все задачи, выполняемые на очереди main, выполняются на главном потоке.</p>

<p>__
Наиболее частые методы взаимодействия с очередями async и sync.
В случае метода async управление возвращается вызывающему потоку:</p>

<p>func testConcurrent() {
    concurrentQueue.async {
        sleep(3) // this will be triggered after ‘test 2’
        print(“test 1”)
    }
    concurrentQueue.async {
        print(“test 2”)
    }
}</p>

<p>Для sync - ожидает выполнение вашей задачи.
Для того что бы отложить выполнение задачи есть asyncAfter()</p>

<p>__
concurrentPerform - Параллельный цикл. Более эффективно применять, нежели использовать dispatchAsync в цикле for:</p>

<p>func test() {
	DispatchQueue.concurrentPerform(iterations: 3, execute: { I in 
		print(i)
	})
}
Особенно эффективен при большом количестве итераций. Использует свободные ресурсы системы.</p>

<p>__
DispatchWorkItem - данный класс, абстракция над выполняемой задачей с рядом удобных методов.</p>

<p>let queue = DispatchQueue(label: “test”)
func testQueue() {
    queue.async {
        sleep(1)
        print(“test 1”)
    }
    let item = DispatchWorkItem {
        print(“test”)
    }
    queue.async(execute: item) // выполнится не успеет
    item.cancel() // отмена задачи
}
Отмена задачи произойдёт, только если задача не была направленна на выполнение(execute).</p>

<p>__</p>

<p>let semaphore = DispatchSemaphore(value: 2)
	// Передавая целочисленное значение в параметр value, мы можем
	// контролировать количество потоков которые могут обращаться к ресурсу. 
func doWork() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>semaphore.wait()
// Вызываем метод wait(), который блокирует наш поток, пока внутри задачи в 	// очередь на выполнение не вызовется метод signal()
print("test")
sleep(3)
semaphore.signal() }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>func test() {
    DispatchQueue.global().async {
        doWork()
    }
    DispatchQueue.global().async {
        doWork()
    }
    DispatchQueue.global().async {
        doWork()
    }
	// Процесс будет исполнятся в первых 2-х случаях, потому что мы 
	// указали value = 2. Когда же 3 поток попробует его захватить - тогда будет
	// ожидание wait() пока не выполнится один из предыдущих потоков.
}</p>

<p>__
Для ситуаций, в которых необходимо определить порядок выполнения задач, можно также воспользоваться DispatchGroup. Он позволяет определять задачи в группы, и затем дожидаться пока не выполнятся все задачи в группе.</p>

<p>let group = DispatchGroup()
let queue = DispatchQueue(label: “DispatchGroupTest1”, attributes: .concurrent)</p>

<p>func testWait() {
    group.enter()
	// Метод enter говорит о том, что мы «заходим» в группу. leave - выходим.
    queue.async {
        sleep(1)
        print(“1”)
        group.leave()
    }
    group.enter()
    queue.async {
        sleep(2)
        print(“2”)
        group.leave()
    }
    group.wait()
	// Метод wait означает, что пока все задачи объединенные в группу, перед 	
	// которыми был вызван метод enter, не завершили свое выполнение, и не 
	// вызвали метод leave вызывающий поток будет блокироваться.
    print(“finished”)
}</p>

<p>__
Что бы реализовать read-write lock в GCD используется Barrier Block. Он ждет пока не выполняется все поставленные ранее блоки в очередь, после этого начинает выполнение своего кода и ставит блок на очередь пока не выполнится сам, далее могут начать выполнятся блоки после него.</p>

<p>let queue = DispatchQueue(label: “DispatchBarrierTest”, attributes: .concurrent)
var internalTest: Int = 0
func setTest(_ test: Int) {
    queue.async(flags: .barrier) {
        internalTest = test
    }
}
func test() -&gt; Int {
    var tmp = 0
    queue.sync {
        tmp = internalTest
    }
    return tmp
}</p>

<p>При таком подходе ресурс блокируется только на запись.</p>

<p>__
DisptachSource - специальный тип GCD, позволяющий взаимодействовать с системными событиями. Есть 4ре вида:</p>
<ol>
  <li>Timer dispatch source - генерирует периодические уведомления</li>
  <li>Signal dispatch source - оповещает о приходе unix сигналов</li>
  <li>Descriptor dispatch source - оповещает что с файлом были произведенные различные операции</li>
  <li>Process dispatch source - оповещает о событиях процесса</li>
</ol>

<p>Все dispatchSource по умолчанию создаются неактивными.</p>

<p>__
Что бы сократись переключение контекста есть targetQueue.</p>

<p>let targetQueue = DispatchQueue(label: “TargetQueue”)
func test() {
    let queue1 = DispatchQueue(label: “Queue1”, target: targetQueue)
    let dispatchSource1 = DispatchSource.makeTimerSource(queue: queue1)
    dispatchSource1.setEventHandler {
        print(“test1”)
    }
    dispatchSource1.schedule(deadline: .now(), repeating: 2)
    dispatchSource1.activate()
}</p>

<p>TargetQueue должна быть serial, при concurrent переключения потоков не избежать.</p>

<p>__
DisptachIO - API для взаимодействия с файловой системой.</p>

<p>Operation</p>

<p>Наследником класса OperationQueue() является BlockOperation:</p>

<p>let operationQueue = OperationQueue()
func test() {
    let blockOperation = BlockOperation {
        print(“test”)
    }
    operationQueue.addOperation(blockOperation)
}</p>

<p>Как только добавляем (addOperation) операцию, она будет выполнена.</p>

<p>Жизненный цикл Operation</p>
<ul>
  <li>isReady говорит о том, что операция готова для выполнения (свойство выставлено в true). Свойство выставлено в false, если зависимые операции еще не выполнились. Обычно у вас нет прямой необходимости для того, чтобы переопределять это свойство. Если готовность ваших операций определяется не только через зависимые операции, вы можете предоставить свою собственную имплементацию isReady и определять готовность операции для выполнения самостоятельно.</li>
  <li>isExecuting означает, что операция выполняется в данный момент. True если операция выполняется, false если нет. Если вы переопределяете метод start, вы также должны переопределить isExecuting и отправлять kvo нотификации, когда статус выполнения вашей операции изменился.</li>
  <li>isFinished означает, что операция была успешно завершена или отменена. Пока свойство будет выставлено в false, операция будет находиться в operation queue. Если вы переопределяете метод start, вы также должны переопределить isFinished и отправлять kvo нотификации, когда ваша операция будет выполнена или отменена.</li>
  <li>isCancelled означает, что запрос об отмене операции был отправлен. Поддержку отмены операции вы должны реализовать самостоятельно.</li>
</ul>

<p>isAsynchronous - является ли операция асинхронной.</p>

<p>Методы:
start() - начать выполнение операции
main() - определяем основной функционал</p>

<p>__
OperationQueue - очередь FIFO.  Запускает операции асинхронно.</p>

<p>let operationQueue = OperationQueue()
class OperationA: Operation { // пример создания кастомной operation 
    override func main() {
        print(“test”)
    }
}
func test() {
    let testOperation = OperationA()
    operationQueue.addOperation(testOperation)
}</p>

<p>__
Работая без operationQueue, операция создается по умолчанию синхронной.
Операция запускается из потока, откуда вызвали метод start()
Можно создать асинхронную операцию, где сами определяем поток выполнения.
при создании асинхронной операции нужно переопределять свойства isAsynchronous, isFinished и isExecuting</p>

<p>class AsyncOperation: Operation {
    private var finish = false
    private var execute = false
    private let queue = DispatchQueue(label: “AsyncOperation”)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>override var isAsynchronous: Bool { return true }
override var isFinished: Bool { return finish }
override var isExecuting: Bool { return execute }

override func start() {
    queue.async {
        self.main()
    }
    execute = true
}

override func main() {
    print("test")
    finish = true
    execute = false
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>__
Свойство OperationQueue maxConcurrentOperationCount позволяет определить колл-во одновременно выполняемых операций. 
///</p>

<p>operationQueue.maxConcurrentOperationCount = 1
operationQueue.addOperation { sleep(1); print(«test1») }
operationQueue.addOperation { sleep(1); print(«test2») }
operationQueue.addOperation { sleep(1); print(«test3») }
///
Т.е. Одновременно, в данном случае, может выполняется только 1 операция. Как только первая операция будет выполнена, пойдет вторая, и тд.</p>

<p>__
Еще одно ключевое преимущество операция над GCD является Dependencies.
Они позволяет определять порядок выполнения операций:</p>

<p>let operationQueue = OperationQueue()
let operation1 = BlockOperation { print(“test1”) }
let operation2 = BlockOperation { print(“test2”) }
let operation3 = BlockOperation { print(“test3”) }
operation3.addDependency(operation2)
operationQueue.addOperations([operation1, operation2, operation3], waitUntilFinished: false) // метод waitUntil</p>

<p>Метод waitUntil блокирует вызывающий поток, пока все операций находящиеся в operationQueue не будут выполнены.
Также может быть написан как:
operationQueue.watiUntilAllOperationsAreFinished()</p>

<p>__
CompletionBlock - код который будет выполнятся по окончанию выполнения операции:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">func</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">let</span> <span class="nv">operation</span> <span class="o">=</span> <span class="kt">BlockOperation</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="err">«</span><span class="n">test</span><span class="err">»</span><span class="p">)</span> <span class="p">}</span>
	<span class="n">operation</span><span class="o">.</span><span class="n">completionBlock</span> <span class="o">=</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="err">«</span><span class="n">finished</span><span class="err">»</span><span class="p">)</span> <span class="p">}</span>
	<span class="n">operationQueue</span><span class="o">.</span><span class="nf">addOperation</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>__
suspend позволяет приостановить выполнение operationQueue.
operationQueue.isSuspended = true
Остановка очереди происходит не сразу. Очередь дожидается пока не текущая выполняемая операция не будет выполнена.</p>

<p>__
GCD vs OPERATION</p>

<p>Operation - под капотом GCD. Высокоуровневая абстракция.
	Преимущества: Cancelation, Observable, Dependencies
GDC - более низкоуровневый примитив.
	Преимущества: Простота, Низкоуровневость.</p>

:ET